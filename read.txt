Hello :-)

I am making this README file in order to help the instructors/markers to better understand my code.

I made several "haskell-quoridor" files, where each time there are differences in my code.
I had to use different files for different parts of the cw, as some of my answers clashed with others.


Here is the explanation for each file:

- "haskell-quoridor-basic" :
    In this file I implemented the basic functions of Part I that we are asked to do in the instruction document of the cw.
    In particular, the ordering is always lowFirst or highFirst (as required from the email that we received), which
    passes the new tests, and also a utility function that is "the higher the better", which also passes the tests.
    So, please run the minimax-tests in that file, as I implemented the functions as required.

    Because we have a utility function that is "the higher the better" for the current player, I made a modified version of a minimax algorithm that only takes
    the minimum value at each sublevel (as we want to minimise the utility of the opponent). Hence, the implementation of minimax is not exactly the same as what we
    have seen in the lectures, but it delivers a quite strong opponent still! This is similar for AB purning, my implementation is correct but that utility
    function does not work with it, so don't use AB pruning in that file.

    In conclusion, that file is only for doing the minimax-tests and to see how my modified minimax algorithm fairs. More
    precisely, it implements the questions I.a, I.b, I.c, I.d and I.e corretly (and for the minimax-tests).


- "haskell-quoridor-minimax-AB-Reed" :
    In this file I changed some few things that make the minimax algorithm correct according to what we have seen
    in the lectures, and that makes AB pruning work (way more efficient compared to minimax, and it takes the same decisions).

    I basically changed the way our utility function calculates a value, by always making sure that the higher the better for MAX,
    and the lower the better for MIN, and in order to remember who is MAX and MIN in the array of players, I give an extra
    argument to the utility function (which is MAX at the start of the tree).

    This way, my eval tree can be ordered from low to high on a level where min takes a decision (hence max is the current player on
    those daughter boards), and from high to low when max takes a decision (hence min is the current player on those daughter boards).
    Hence, the different ordering for this file.

    I then also answered the question about Reed in this file. The file "Reed.txt" can be found in haskell-quoridor-minimax-AB-Reed/src/Players .

    In conclusion, this file answers the questions I.f using the actual minimax algorithm seen in the lectures, question Part II
    and question part III.


- "haskell-quoridor-4" :
    In this file I changed the rules so that four players can play at the same time :D ! I did it in a separate file so that the game
    can still be played with 2 players in the files 'basic' or 'minimax-AB-Reed'. I also changed the minimax algorithm in that file
    so that it still works in this scenario (similar to the one in the file 'basic'). I had to change the ordering of the tree, and also I changed the 
    utility function by adding weigts to the features. The minimax algorithm in that scenario is quite good, but it can still be improved.

    This file is mostly for the extension (part IV), but my second file ('minimax-AB-Reed') could also count as I made two different implementation
    of the minimax algorithm (and of utility function).


- "haskell-quoridor-moves" :
    I was quite annoyed that sometimes the minimax algorithm would take an invalid move that would make it impossible for its opponent
    to reach its goal cells. Hence, in this file I edited the validWallAction method so that it doesn't allow for such walls.
    I did it in a separate file as I didn't want to break anything in the other files.

    This version of the file is the same as 'minimax-AB-reed', so minimax and AB pruning can be done in this file too.

    My solution is very efficient, I didn't notice a difference when I implemented it. (but with larger trees then it will make a difference).

    So, this file can also serve as an extension (part IV).

